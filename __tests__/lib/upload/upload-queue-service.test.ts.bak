import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { UploadQueueService, type QueueStats } from '@/lib/upload/upload-queue-service';

describe('UploadQueueService', () => {
  let service: UploadQueueService<string, void>;

  beforeEach(() => {
    service = new UploadQueueService<string, void>();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('enqueue', () => {
    it('should add item to queue', () => {
      service.enqueue('file-1', 'test-data');
      const stats = service.getStats();
      expect(stats.pending).toBe(1);
      expect(stats.successful).toBe(0);
      expect(stats.failed).toBe(0);
    });

    it('should add multiple items to queue', () => {
      service.enqueue('file-1', 'data-1');
      service.enqueue('file-2', 'data-2');
      service.enqueue('file-3', 'data-3');
      const stats = service.getStats();
      expect(stats.pending).toBe(3);
    });
  });

  describe('enqueueBatch', () => {
    it('should add multiple items at once', () => {
      service.enqueueBatch([
        { id: 'file-1', data: 'data-1' },
        { id: 'file-2', data: 'data-2' },
        { id: 'file-3', data: 'data-3' },
      ]);
      const stats = service.getStats();
      expect(stats.pending).toBe(3);
    });
  });

  describe('processQueue', () => {
    it('should process all items successfully', async () => {
      const handler = vi.fn().mockResolvedValue(undefined);
      const onProgress = vi.fn();

      service.enqueueBatch([
        { id: 'file-1', data: 'data-1' },
        { id: 'file-2', data: 'data-2' },
        { id: 'file-3', data: 'data-3' },
      ]);

      await service.processQueue(handler, onProgress);

      expect(handler).toHaveBeenCalledTimes(3);
      expect(handler).toHaveBeenCalledWith('data-1');
      expect(handler).toHaveBeenCalledWith('data-2');
      expect(handler).toHaveBeenCalledWith('data-3');

      const stats = service.getStats();
      expect(stats.successful).toBe(3);
      expect(stats.failed).toBe(0);
      expect(stats.pending).toBe(0);
      expect(onProgress).toHaveBeenCalled();
    });

    it('should respect concurrency limit', async () => {
      const service = new UploadQueueService<string, void>({
        baseConcurrency: 2,
      });

      let activeCount = 0;
      let maxActive = 0;

      const handler = vi.fn().mockImplementation(async () => {
        activeCount++;
        maxActive = Math.max(maxActive, activeCount);
        await new Promise(resolve => setTimeout(resolve, 10));
        activeCount--;
      });

      service.enqueueBatch([
        { id: 'file-1', data: 'data-1' },
        { id: 'file-2', data: 'data-2' },
        { id: 'file-3', data: 'data-3' },
        { id: 'file-4', data: 'data-4' },
      ]);

      await service.processQueue(handler);

      expect(maxActive).toBeLessThanOrEqual(2);
      expect(handler).toHaveBeenCalledTimes(4);
    });

    it('should retry failed items with exponential backoff', async () => {
      const handler = vi.fn()
        .mockRejectedValueOnce(new Error('First attempt'))
        .mockResolvedValue(undefined);

      service.enqueue('file-1', 'data-1');

      await service.processQueue(handler);

      expect(handler).toHaveBeenCalledTimes(2); // Initial + 1 retry
      const stats = service.getStats();
      expect(stats.successful).toBe(1);
      expect(stats.failed).toBe(0);
    });

    it('should exhaust retries and mark as failed', async () => {
      const handler = vi.fn().mockRejectedValue(new Error('Always fails'));

      service.enqueue('file-1', 'data-1');

      await service.processQueue(handler);

      // Should be called: initial + 3 retries = 4 times
      expect(handler).toHaveBeenCalledTimes(4);
      const stats = service.getStats();
      expect(stats.successful).toBe(0);
      expect(stats.failed).toBe(1);
    });

    it('should adjust concurrency based on failure rate', async () => {
      const service = new UploadQueueService<string, void>({
        baseConcurrency: 6,
        minConcurrency: 2,
        maxConcurrency: 8,
        failureRateThreshold: 0.2,
        maxRetries: 0, // Disable retries for this test
      });

      // Create handler that fails 30% of the time
      let callCount = 0;
      const handler = vi.fn().mockImplementation(async () => {
        callCount++;
        if (callCount % 10 < 3) {
          throw new Error('Simulated failure');
        }
      });

      // Enqueue 20 items
      const items = Array.from({ length: 20 }, (_, i) => ({
        id: `file-${i}`,
        data: `data-${i}`,
      }));
      service.enqueueBatch(items);

      const initialConcurrency = service.getConcurrency();
      expect(initialConcurrency).toBe(6);

      await service.processQueue(handler);

      // Concurrency should have decreased due to high failure rate
      const finalConcurrency = service.getConcurrency();
      expect(finalConcurrency).toBeLessThan(initialConcurrency);
    });

    it('should increase concurrency with low failure rate', async () => {
      const service = new UploadQueueService<string, void>({
        baseConcurrency: 4,
        minConcurrency: 2,
        maxConcurrency: 8,
        successRateThreshold: 0.95,
      });

      // Handler succeeds 100% of the time
      const handler = vi.fn().mockResolvedValue(undefined);

      // Enqueue 20 items
      const items = Array.from({ length: 20 }, (_, i) => ({
        id: `file-${i}`,
        data: `data-${i}`,
      }));
      service.enqueueBatch(items);

      const initialConcurrency = service.getConcurrency();
      expect(initialConcurrency).toBe(4);

      const processPromise = service.processQueue(handler);
      await vi.runAllTimersAsync();
      await processPromise;

      // Concurrency should have increased due to low failure rate
      const finalConcurrency = service.getConcurrency();
      expect(finalConcurrency).toBeGreaterThan(initialConcurrency);
    });

    it('should call progress callback on updates', async () => {
      const handler = vi.fn().mockResolvedValue(undefined);
      const onProgress = vi.fn();

      service.enqueueBatch([
        { id: 'file-1', data: 'data-1' },
        { id: 'file-2', data: 'data-2' },
      ]);

      await service.processQueue(handler, onProgress);

      // Should be called at least: 2 enqueues + 2 successes
      expect(onProgress.mock.calls.length).toBeGreaterThanOrEqual(4);

      // Check that stats are passed
      const lastCall = onProgress.mock.calls[onProgress.mock.calls.length - 1][0];
      expect(lastCall).toHaveProperty('successful');
      expect(lastCall).toHaveProperty('failed');
      expect(lastCall).toHaveProperty('pending');
      expect(lastCall).toHaveProperty('retrying');
    });

    it('should handle mixed success and failure', async () => {
      const handler = vi.fn()
        .mockResolvedValueOnce(undefined) // file-1 succeeds
        .mockRejectedValueOnce(new Error('Fail')) // file-2 fails
        .mockResolvedValueOnce(undefined) // file-3 succeeds
        .mockResolvedValueOnce(undefined); // file-2 retry succeeds

      service.enqueueBatch([
        { id: 'file-1', data: 'data-1' },
        { id: 'file-2', data: 'data-2' },
        { id: 'file-3', data: 'data-3' },
      ]);

      const processPromise = service.processQueue(handler);
      await vi.runAllTimersAsync();
      await processPromise;

      expect(handler).toHaveBeenCalledTimes(4); // 3 initial + 1 retry
      const stats = service.getStats();
      expect(stats.successful).toBe(3);
      expect(stats.failed).toBe(0);
    });
  });

  describe('clear', () => {
    it('should clear queue and reset stats', () => {
      service.enqueueBatch([
        { id: 'file-1', data: 'data-1' },
        { id: 'file-2', data: 'data-2' },
      ]);

      let stats = service.getStats();
      expect(stats.pending).toBe(2);

      service.clear();

      stats = service.getStats();
      expect(stats.pending).toBe(0);
      expect(stats.successful).toBe(0);
      expect(stats.failed).toBe(0);
      expect(stats.retrying).toBe(0);
    });
  });

  describe('getConcurrency', () => {
    it('should return current concurrency limit', () => {
      const service = new UploadQueueService<string, void>({
        baseConcurrency: 4,
      });
      expect(service.getConcurrency()).toBe(4);
    });
  });

  describe('custom configuration', () => {
    it('should respect custom max retries', async () => {
      const service = new UploadQueueService<string, void>({
        maxRetries: 1,
      });

      const handler = vi.fn().mockRejectedValue(new Error('Always fails'));

      service.enqueue('file-1', 'data-1');

      const processPromise = service.processQueue(handler);
      await vi.runAllTimersAsync();
      await processPromise;

      // Should be called: initial + 1 retry = 2 times
      expect(handler).toHaveBeenCalledTimes(2);

      const stats = service.getStats();
      expect(stats.failed).toBe(1);
    });

    it('should respect custom backoff delays', async () => {
      const service = new UploadQueueService<string, void>({
        backoffDelays: [100, 200, 400],
      });

      const handler = vi.fn()
        .mockRejectedValueOnce(new Error('First attempt'))
        .mockResolvedValue(undefined);

      service.enqueue('file-1', 'data-1');

      await service.processQueue(handler);

      expect(handler).toHaveBeenCalledTimes(2); // Initial + 1 retry
      const stats = service.getStats();
      expect(stats.successful).toBe(1);
    });

    it('should respect concurrency bounds', async () => {
      const service = new UploadQueueService<string, void>({
        baseConcurrency: 10,
        minConcurrency: 5,
        maxConcurrency: 15,
      });

      expect(service.getConcurrency()).toBe(10);

      // Concurrency adjustments should stay within bounds
      const handler = vi.fn().mockResolvedValue(undefined);

      const items = Array.from({ length: 50 }, (_, i) => ({
        id: `file-${i}`,
        data: `data-${i}`,
      }));
      service.enqueueBatch(items);

      await service.processQueue(handler);

      const concurrency = service.getConcurrency();
      expect(concurrency).toBeGreaterThanOrEqual(5);
      expect(concurrency).toBeLessThanOrEqual(15);
    });
  });

  describe('edge cases', () => {
    it('should handle empty queue', async () => {
      const handler = vi.fn();
      const onProgress = vi.fn();

      await service.processQueue(handler, onProgress);

      expect(handler).not.toHaveBeenCalled();
      const stats = service.getStats();
      expect(stats.successful).toBe(0);
      expect(stats.failed).toBe(0);
    });

    it('should handle single item queue', async () => {
      const handler = vi.fn().mockResolvedValue(undefined);

      service.enqueue('file-1', 'data-1');

      await service.processQueue(handler);

      expect(handler).toHaveBeenCalledTimes(1);
      const stats = service.getStats();
      expect(stats.successful).toBe(1);
    });

    it('should handle all items failing permanently', async () => {
      const handler = vi.fn().mockRejectedValue(new Error('Always fails'));

      service.enqueueBatch([
        { id: 'file-1', data: 'data-1' },
        { id: 'file-2', data: 'data-2' },
      ]);

      const processPromise = service.processQueue(handler);
      await vi.runAllTimersAsync();
      await processPromise;

      const stats = service.getStats();
      expect(stats.successful).toBe(0);
      expect(stats.failed).toBe(2);
    });
  });
});
